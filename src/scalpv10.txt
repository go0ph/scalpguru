#property strict
#property description "ScalpGuru V9 - Buy-Only HH TP Edition"
#property description "TP at last major higher high, partial at halfway to TP, sells disabled"
#property version   "9.02"
#property copyright "Created by go0ph (Buy-Only HH TP Mod by Copilot 2026)"

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
//| Input Parameters                                                  |
//+------------------------------------------------------------------+
//--- Trading Configuration
input group "=== Trading Configuration ==="
input int MagicNumber = 15139;              
input double AccountBalance = 6000.0;       
input double RiskPerTradePercent = 1.0;     
input bool EnableRiskPerTrade = true;       
input double ManualLotSize = 0.01;          
input double MaxLossPercent = 1;            
input int MaxTradesPerDay = 4;              
input bool EnableMaxTradesPerDay = true;    

//--- Funded Account Protection
input group "=== Funded Account Protection ==="
input bool EnableFundedMode = true;          
input double DailyLossLimitPercent = 2.5;    
input double MaxDrawdownPercent = 5.5;       
input double ProfitTargetPercent = 10.0;     

//--- Strategy Parameters
input group "=== Strategy Parameters ==="
input int ATRPeriod = 133;                   
input int KeltnerPeriod = 64;               
input double KeltnerMultiplier = 3.75;       
input double SL_ATRMultiplier = 7.54;         
input double BreakevenBuffer = 2.46;         

//--- Profit Taking Parameters
input group "=== Profit Taking ==="
input bool EnablePartialProfit = true;       
input double PartialProfitPercent = 50.0;    

//--- HH Swing High detection parameters
input group "=== HH Swing High TP Setting ==="
input int SwingLookback = 319;       // How far back (bars) to search for HH
input int SwingWindow = 58;           // Width (bars on each side) for swing high

//--- Entry Filters
input group "=== Entry Filters ==="
input bool EnableMomentumFilter = true;     
input int RSIPeriod = 128;                   
input int RSI_Oversold = 53;                
input int RSI_Overbought = 645;              
input bool EnableVolumeFilter = false;      
input double VolumeMultiplier = 1.2;        
input bool EnableCandleConfirmation = true; 

//--- V9: Data-Driven Enhancements
input group "=== V9 Data-Driven Features ==="
input bool EnableVolatilityAdjustedRisk = true;   
input double VolLowRiskMultiplier = 6.36;          
input double VolHighRiskMultiplier = 7.28;         
input bool EnableVolatilityAdjustedStops = true;  
input double HighVolStopMultiplier = 2.7;         

//--- Session Filter
input group "=== Session Filter ==="
input bool EnableSessionFilter = false;     
input int SessionStartHour = 8;             
input int SessionEndHour = 20;             

//--- Day Filtering
input group "=== Day Filtering ==="
input bool EnableDaySkip = true;           
input bool SkipMonday = false;              
input bool SkipTuesday = false;             
input bool SkipWednesday = false;           
input bool SkipThursday = false;            
input bool SkipFriday = true;               

//--- Month Filtering
input group "=== Month Filtering ==="
input bool EnableMonthSkip = false;         
input bool SkipJanuary = false;             
input bool SkipFebruary = false;            
input bool SkipMarch = false;               
input bool SkipApril = false;               
input bool SkipMay = false;                 
input bool SkipJune = false;                
input bool SkipJuly = false;                
input bool SkipAugust = false;              
input bool SkipSeptember = false;           
input bool SkipOctober = false;             
input bool SkipNovember = false;            
input bool SkipDecember = false;            

//--- Visual Settings
input group "=== Visual Settings ==="
input bool ShowKeltnerOnChart = true;       
input bool ShowInfoPanel = true;            
input bool ShowTradeArrows = true;          

input color KeltnerUpperColor = clrCrimson;       
input color KeltnerMiddleColor = clrDodgerBlue;   
input color KeltnerLowerColor = clrLimeGreen;     
input color KeltnerFillColor = clrLavender;       
input color PanelBackgroundColor = clrBlack;      
input color PanelTextColor = clrWhite;            
input color PanelProfitColor = clrLime;           
input color PanelLossColor = clrRed;              
input color BuyArrowColor = clrLime;              
input int KeltnerBarsToShow = 100;                

//--- Global Variables
double atrValue, keltnerUpper, keltnerLower, keltnerMid;
bool inTrade = false;
ENUM_TIMEFRAMES timeframe;
int atrHandle, maHandle, rsiHandle;
double atrBuffer[], maBuffer[], closeBuffer[], rsiBuffer[], highBuffer[], lowBuffer[], openBuffer[];
int tradesToday = 0;
datetime lastTradeDay = 0;
double entryPrice = 0;
double initialSL = 0;
datetime lastBarTime = 0;  
bool partialProfitTaken = false;  
double originalLotSize = 0;       
double currentTakeProfit = 0;     // Store per-position TP

// Funded Account Protection Variables
double dailyStartBalance = 0;     
double overallStartBalance = 0;   
double dailyPnL = 0;              
bool dailyLimitHit = false;       
bool drawdownLimitHit = false;    
bool profitTargetReached = false; 

// Constants
#define PIPS_TO_POINTS 10
#define CANDLE_WICK_RATIO 0.6    
#define CANDLE_BODY_RATIO 0.4    

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   timeframe = Period();
   trade.SetExpertMagicNumber(MagicNumber);
   
   atrHandle = iATR(_Symbol, timeframe, ATRPeriod);
   if(atrHandle == INVALID_HANDLE) return INIT_FAILED;
   
   maHandle = iMA(_Symbol, timeframe, KeltnerPeriod, 0, MODE_EMA, PRICE_CLOSE);
   if(maHandle == INVALID_HANDLE)
   {
      IndicatorRelease(atrHandle);
      return INIT_FAILED;
   }
   
   // RSI
   if(EnableMomentumFilter)
   {
      rsiHandle = iRSI(_Symbol, timeframe, RSIPeriod, PRICE_CLOSE);
      if(rsiHandle == INVALID_HANDLE)
      {
         IndicatorRelease(atrHandle); IndicatorRelease(maHandle);
         return INIT_FAILED;
      }
      ArraySetAsSeries(rsiBuffer, true);
   }
   
   ArraySetAsSeries(atrBuffer, true);
   ArraySetAsSeries(maBuffer, true);
   ArraySetAsSeries(closeBuffer, true);
   ArraySetAsSeries(highBuffer, true);  
   ArraySetAsSeries(lowBuffer, true);   
   ArraySetAsSeries(openBuffer, true);  

   if(ATRPeriod <= 0 || KeltnerPeriod <= 0) return INIT_PARAMETERS_INCORRECT;
   if(SL_ATRMultiplier <= 0 || KeltnerMultiplier <= 0) return INIT_PARAMETERS_INCORRECT;
   if(ManualLotSize <= 0) return INIT_PARAMETERS_INCORRECT;
   if(MaxLossPercent <= 0 || MaxLossPercent > 100) return INIT_PARAMETERS_INCORRECT;
   if(RiskPerTradePercent <= 0 || RiskPerTradePercent > 100) return INIT_PARAMETERS_INCORRECT;

   if(EnableFundedMode)
   {
      if(DailyLossLimitPercent <= 0 || DailyLossLimitPercent > 100) return INIT_PARAMETERS_INCORRECT;
      if(MaxDrawdownPercent <= 0 || MaxDrawdownPercent > 100) return INIT_PARAMETERS_INCORRECT;
      if(ProfitTargetPercent <= 0) return INIT_PARAMETERS_INCORRECT;
   }
   if(EnablePartialProfit)
   {
      if(PartialProfitPercent <= 0 || PartialProfitPercent > 100) return INIT_PARAMETERS_INCORRECT;
   }
   if(MaxTradesPerDay <= 0) return INIT_PARAMETERS_INCORRECT;
   
   MqlDateTime dt;
   TimeToStruct(TimeTradeServer(), dt);
   dt.hour = 0; dt.min = 0; dt.sec = 0;
   lastTradeDay = StructToTime(dt);

   if(EnableFundedMode)
   {
      overallStartBalance = AccountBalance;
      dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
      dailyPnL = 0; dailyLimitHit = false; drawdownLimitHit = false; profitTargetReached = false;
   }
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Deinit                                                           |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   ObjectsDeleteAll(0, "KC_");
   ObjectsDeleteAll(0, "SG_");
   IndicatorRelease(atrHandle);
   IndicatorRelease(maHandle);
   if(EnableMomentumFilter && rsiHandle != INVALID_HANDLE)
      IndicatorRelease(rsiHandle);
}

//+------------------------------------------------------------------+
//| Find Last Major Higher High (Swing High)                         |
//+------------------------------------------------------------------+
double FindLastMajorHigh(int lookback, int swing_window)
{
   double hh = 0;
   int bars = CopyHigh(_Symbol, timeframe, 0, lookback, highBuffer);
   if(bars < swing_window*2+2) return 0;
   for(int i = swing_window+1; i < lookback - swing_window; i++)
   {
      bool is_hh = true;
      double candidate = highBuffer[i];
      for(int j = 1; j <= swing_window; j++)
      {
         if(candidate <= highBuffer[i-j] || candidate <= highBuffer[i+j])
         {
            is_hh = false; break;
         }
      }
      if(is_hh && candidate > hh)
         hh = candidate;
   }
   return hh;
}

//+------------------------------------------------------------------+
//| Session Filter                                                   |
//+------------------------------------------------------------------+
bool CheckSessionFilter()
{
   if(!EnableSessionFilter) return true;
   MqlDateTime dt; TimeToStruct(TimeTradeServer(), dt);
   int currentHour = dt.hour;
   if(SessionStartHour < SessionEndHour)
      return (currentHour >= SessionStartHour && currentHour < SessionEndHour);
   else
      return (currentHour >= SessionStartHour || currentHour < SessionEndHour);
}

//+------------------------------------------------------------------+
//| Funded Account Checks                                            |
//+------------------------------------------------------------------+
bool CheckFundedAccountLimits()
{
   if(!EnableFundedMode) return true;
   double currentBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double effectiveEquity = MathMin(currentBalance, currentEquity);
   double overallDrawdown = MathMax(0, overallStartBalance - effectiveEquity);
   double maxAllowedDrawdown = overallStartBalance * (MaxDrawdownPercent / 100);
   double profit = effectiveEquity - overallStartBalance;
   double targetAmount = overallStartBalance * (ProfitTargetPercent / 100);

   if(profit >= targetAmount && !profitTargetReached) { profitTargetReached = true; }
   if(overallDrawdown >= maxAllowedDrawdown)
   {
      if(!drawdownLimitHit) { drawdownLimitHit = true; CloseAllPositions(); }
      return false;
   }
   double dailyEquityChange = effectiveEquity - dailyStartBalance;
   double dailyLossLimit = overallStartBalance * (DailyLossLimitPercent / 100);
   if(dailyEquityChange <= -dailyLossLimit)
   {
      if(!dailyLimitHit) { dailyLimitHit = true; CloseAllPositions(); }
      return false;
   }
   return true;
}

void CloseAllPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         trade.PositionClose(ticket);
   }
   inTrade = false;
   partialProfitTaken = false;
}

//+------------------------------------------------------------------+
//| Check Momentum (RSI)                                             |
//+------------------------------------------------------------------+
bool CheckMomentumFilter()
{
   if(!EnableMomentumFilter) return true;
   if(CopyBuffer(rsiHandle, 0, 0, 3, rsiBuffer) <= 0) return true;
   double rsi = rsiBuffer[0];
   return (rsi <= RSI_Overbought);
}

//+------------------------------------------------------------------+
//| Check Volume                                                     |
//+------------------------------------------------------------------+
bool CheckVolumeFilter()
{
   if(!EnableVolumeFilter) return true;
   long currentVolume = iVolume(_Symbol, timeframe, 0);
   long totalVolume = 0;
   for(int i = 1; i <= 20; i++) totalVolume += iVolume(_Symbol, timeframe, i);
   double avgVolume = totalVolume / 20.0;
   return (currentVolume >= avgVolume * VolumeMultiplier);
}

//+------------------------------------------------------------------+
//| Candle Confirmation                                              |
//+------------------------------------------------------------------+
bool CheckCandleConfirmation()
{
   if(!EnableCandleConfirmation) return true;
   if(ArraySize(closeBuffer) < 3 || ArraySize(openBuffer) < 3) return true;
   double close1 = closeBuffer[1], open1 = openBuffer[1], high1 = highBuffer[1], low1 = lowBuffer[1];
   double candleBody = MathAbs(close1 - open1);
   double candleRange = high1 - low1;
   bool isBullish = close1 > open1;
   bool isHammer = (candleRange > 0) && ((close1-low1) > CANDLE_WICK_RATIO*candleRange) && (candleBody < CANDLE_BODY_RATIO*candleRange);
   double currentClose = closeBuffer[0], currentOpen = openBuffer[0];
   bool currentBullish = currentClose > currentOpen;
   return isBullish || isHammer || currentBullish;
}

//+------------------------------------------------------------------+
//| Calculate Lot Size                                               |
//+------------------------------------------------------------------+
double GetVolatilityMultiplier()
{
   if(!EnableVolatilityAdjustedRisk) return 1.0;
   if(atrValue < 5.58) return VolLowRiskMultiplier;
   else if(atrValue > 14.74) return VolHighRiskMultiplier;
   return 1.0;
}

double GetVolatilityAdjustedSL()
{
   if(!EnableVolatilityAdjustedStops) return SL_ATRMultiplier;
   if(atrValue > 14.74) return SL_ATRMultiplier * HighVolStopMultiplier;
   return SL_ATRMultiplier;
}

double CalculateLotSize(double price)
{
   if(EnableRiskPerTrade)
   {
      double volMultiplier = GetVolatilityMultiplier();
      double riskAmount = AccountBalance * (RiskPerTradePercent * volMultiplier / 100.0);
      double slMultiplier = GetVolatilityAdjustedSL();
      double slDistance = slMultiplier * atrValue;
      double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      if(tickSize == 0 || tickValue == 0) return NormalizeDouble(ManualLotSize, 2);
      double slPoints = slDistance / tickSize;
      double lotSize = NormalizeDouble(riskAmount / (slPoints * tickValue), 2);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
      if(lotSize < minLot) lotSize = minLot;
      if(lotSize > maxLot) lotSize = maxLot;
      return lotSize;
   }
   else
   {
      return NormalizeDouble(ManualLotSize, 2);
   }
}

//+------------------------------------------------------------------+
//| Draw Trade Arrow                                                 |
//+------------------------------------------------------------------+
void DrawTradeArrow(double price, datetime time)
{
   if(!ShowTradeArrows) return;
   string arrowName = "SG_Arrow_" + IntegerToString((long)time);
   ObjectCreate(0, arrowName, OBJ_ARROW, 0, time, price);
   ObjectSetInteger(0, arrowName, OBJPROP_ARROWCODE, 233); // Up arrow
   ObjectSetInteger(0, arrowName, OBJPROP_COLOR, BuyArrowColor);
   ObjectSetInteger(0, arrowName, OBJPROP_WIDTH, 3);
   ObjectSetInteger(0, arrowName, OBJPROP_ANCHOR, ANCHOR_TOP);
   ChartRedraw();
}

//+------------------------------------------------------------------+
//| Open Buy Trade (with TP at last HH)                              |
//+------------------------------------------------------------------+
void OpenBuyTrade()
{
   double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double lotSize = CalculateLotSize(price);
   double sl = NormalizeDouble(price - SL_ATRMultiplier * atrValue, _Digits);
   double takeProfit = FindLastMajorHigh(SwingLookback, SwingWindow);
   if(takeProfit <= price)
      takeProfit = price + 2*atrValue;
   currentTakeProfit = takeProfit;

   double margin;
   if(!OrderCalcMargin(ORDER_TYPE_BUY, _Symbol, lotSize, price, margin)) return;
   if(AccountInfoDouble(ACCOUNT_MARGIN_FREE) < margin) return;

   if(trade.Buy(lotSize, _Symbol, price, sl, takeProfit, "ScalpGuru BUY ONLY HH TP"))
   {
      inTrade = true;
      tradesToday++;
      partialProfitTaken = false;
      originalLotSize = lotSize;
      entryPrice = price;
      initialSL = sl;
      DrawTradeArrow(price, TimeCurrent());
   }
}

//+------------------------------------------------------------------+
//| Manage Open Buy Trades & Partial TP at halfway                   |
//+------------------------------------------------------------------+
void ManageTrades()
{
   ulong posTicket = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0 && PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
      {
         posTicket = ticket;
         break;
      }
   }
   if(posTicket == 0) {
      inTrade = false; partialProfitTaken = false; return;
   }
   if(!PositionSelectByTicket(posTicket)) { inTrade = false; partialProfitTaken = false; return; }

   double entry = PositionGetDouble(POSITION_PRICE_OPEN);
   double currentSL = PositionGetDouble(POSITION_SL);
   double currentVolume = PositionGetDouble(POSITION_VOLUME);
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // Max loss protection
   double floating = PositionGetDouble(POSITION_PROFIT);
   double threshold = -MaxLossPercent / 100.0 * AccountBalance;
   if(floating < threshold)
   {
      if(trade.PositionClose(posTicket))
      {
         inTrade = false; partialProfitTaken = false;
      }
      return;
   }

   // Partial profit at halfway to TP
   double halfway_to_TP = entry + (currentTakeProfit - entry) / 2.0;
   if(EnablePartialProfit && !partialProfitTaken && currentPrice >= halfway_to_TP)
   {
      double closeVolume = NormalizeDouble(currentVolume * (PartialProfitPercent / 100.0), 2);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double remainingVolume = currentVolume - closeVolume;
      if(closeVolume >= minLot && remainingVolume >= minLot)
      {
         if(trade.PositionClosePartial(posTicket, closeVolume))
         {
            partialProfitTaken = true;
         }
      }
      else { partialProfitTaken = true; }
   }
   inTrade = true;
}

//+------------------------------------------------------------------+
//| ON TICK                                                          |
//+------------------------------------------------------------------+
void OnTick()
{
   datetime serverTime = TimeTradeServer();
   MqlDateTime timeStruct; TimeToStruct(serverTime, timeStruct);
   int currentDay = timeStruct.day_of_week, currentMonth = timeStruct.mon;
   MqlDateTime dt; TimeToStruct(serverTime, dt); dt.hour = 0; dt.min = 0; dt.sec = 0;
   datetime todayStart = StructToTime(dt);

   // Reset daily counters
   if(todayStart != lastTradeDay)
   {
      tradesToday = 0;
      lastTradeDay = todayStart;
      if(EnableFundedMode)
      {
         dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
         dailyLimitHit = false;
      }
   }

   if(EnableFundedMode && !CheckFundedAccountLimits())
   {
      ManageTrades(); return;
   }

   bool skipCurrentMonth = false, skipCurrentDay = false;
   if(EnableMonthSkip)
   {
      if((currentMonth == 1 && SkipJanuary) || (currentMonth == 2 && SkipFebruary) || (currentMonth == 3 && SkipMarch) ||
         (currentMonth == 4 && SkipApril) || (currentMonth == 5 && SkipMay) || (currentMonth == 6 && SkipJune) ||
         (currentMonth == 7 && SkipJuly) || (currentMonth == 8 && SkipAugust) || (currentMonth == 9 && SkipSeptember) ||
         (currentMonth == 10 && SkipOctober) || (currentMonth == 11 && SkipNovember) || (currentMonth == 12 && SkipDecember))
         skipCurrentMonth = true;
   }
   if(EnableDaySkip)
   {
      if((currentDay == 1 && SkipMonday) || (currentDay == 2 && SkipTuesday) ||
         (currentDay == 3 && SkipWednesday) || (currentDay == 4 && SkipThursday) || (currentDay == 5 && SkipFriday))
         skipCurrentDay = true;
   }
   bool isSkipped = skipCurrentMonth || skipCurrentDay;

   if(CopyBuffer(atrHandle, 0, 0, 3, atrBuffer) <= 0 || CopyClose(_Symbol, timeframe, 0, 5, closeBuffer) <= 0) return;
   atrValue = atrBuffer[0];
   CopyHigh(_Symbol, timeframe, 0, 5, highBuffer); 
   CopyLow(_Symbol, timeframe, 0, 5, lowBuffer); 
   CopyOpen(_Symbol, timeframe, 0, 5, openBuffer);
   ArraySetAsSeries(highBuffer, true); ArraySetAsSeries(lowBuffer, true); ArraySetAsSeries(openBuffer, true);
   if(EnableMomentumFilter) CopyBuffer(rsiHandle, 0, 0, 3, rsiBuffer);

   if(!isSkipped)
   {
      if(CopyBuffer(maHandle, 0, 0, 3, maBuffer) <= 0) return;
      double ema = maBuffer[0];
      keltnerUpper = MathMax(ema + KeltnerMultiplier * atrValue, 0);
      keltnerLower = MathMax(ema - KeltnerMultiplier * atrValue, 0);
      keltnerMid = ema;
      double close2 = closeBuffer[2], close1 = closeBuffer[1], currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      // Entry conditions
      if(!inTrade && (!EnableMaxTradesPerDay || tradesToday < MaxTradesPerDay))
      {
         if(CheckSessionFilter())
         {
            if(close2 < keltnerLower && currentPrice > keltnerLower)
            {
               if(CheckMomentumFilter() && CheckVolumeFilter() && CheckCandleConfirmation())
               {
                  OpenBuyTrade();
               }
            }
         }
      }
   }
   ManageTrades();
}